function [tt, Z_removal, Z_residual] = dwell_time_2d_rect_udo_rise(...
    X, ... surface x coordinates
    Y, ... surface y coordinates
    Z, ... figure errors int the clear aperture to be removed [m]
    Xp, ...  x coordinates for the dwell positions [m]
    Yp, ...  y coordinates for the dwell positions [m]
    tif_params, ... tif parameters
    tif_mode, ... 'model' or 'interp'
    Xtif, ... tif x coordinates
    Ytif, ... tif y coordinates
    Ztif, ... tif height [m]
    rms_thrd, ... rms threshold for RISE [m]
    ini_order_m, ... y orders for the initial poly extension
    ini_order_n, ... x orders for the initial poly extension
    ini_type, ... polynomial orders & type for the initial extension
    iter_order_m, ... y orders for the iterative poly extension
    iter_order_n, ... x orders for the iterative poly extension
    iter_type, ... polynomial orders & type for iterative refinement
    learning_rate, ... learning rate for the iterative refinement
    max_iter, ... maximum number of iterations for the iterative refinement
    t_min, ... minimum dwell time for one dwell point
    ratio, ... ratio of the dwell time
    is_show_result ... whether display the middle results or not
)
%-------------------------------------------------------------------------%
% Purpose:
%     Implement the Universal Dwell Time Agorithm for rectangular
%     surfaces
% Reference:
%     Wang, Tianyi, et al. "Universal dwell time optimization for 
%     deterministic optics fabrication." Optics Express 29.23 (2021): 
%     38737-38757.
% Info:
%   Contact: tianyiwang666@gmail.com (Dr WANG Tianyi)
%   Copyright reserved.
%-------------------------------------------------------------------------%

surf_mpp = median(diff(X(1, :)));
m = size(Z, 1);
n = size(Z, 2);

%% 0. build TIF
if strcmp(tif_mode, 'model')
    tif_mpp = surf_mpp;    % sampling interval of the beam
    r = tif_params.d * 0.5;    % radius of the TIF
    hf_win_sz = round(r / tif_mpp);    % half windows size of the TIF [pixel]
    
    % generate the X, Y coordinates for the brf
    [Xtif, Ytif] = meshgrid(-hf_win_sz: hf_win_sz, -hf_win_sz: hf_win_sz);
    Ytif = -Ytif;
    Xtif = Xtif * tif_mpp;
    Ytif = Ytif * tif_mpp;
    
    % calculated Z_brf using the theoretical model
    Ztif = tif_2d_super_gauss(...
        Xtif, ...
        Ytif, ...
        1, ...
        [tif_params.A; tif_params.p; tif_params.sigma_xy(:); tif_params.mu_xy(:)]...
    );
    tif_params.tif_mpp = tif_mpp;
    
elseif strcmp(tif_mode, 'interp')
    tif_mpp = median(diff(Xtif(1, :)));
    
else
    error('Invalid TIF mode selected');
    
end


%% 1. calculate the extension size
m_ext = floor(tif_mpp * (size(Ztif, 1)) * 0.5 / surf_mpp);    % extension size in y [pixel]
n_ext = floor(tif_mpp * (size(Ztif, 2)) * 0.5 / surf_mpp);    % extension size in x [pixel]

% y start & end ids of CA in FA [pixel]
ca_range.vs = m_ext + 1;
ca_range.ve = ca_range.vs + m - 1;   

% x start & end ids of CA in FA [pixel]
ca_range.us = n_ext + 1;   
ca_range.ue = ca_range.us + n - 1;

% dwell grid
[Xdg, Ydg] = meshgrid(-n_ext: n - 1 + n_ext, -m_ext: m - 1 + m_ext);
Ydg = m - 1 - Ydg;
Xdg = Xdg * surf_mpp + X(1, 1);      % adjust X grid add X(1,1)
Ydg = Ydg * surf_mpp + Y(end, end);  % adjust Y grid add Y(1,1)


%% 2. Iteratively calculate dwell time based on t_min and t_max
% 2.1 initial conditions
Z_to_remove = Z - nanmin(Z(:));

% 2.2 build TIF matrices based on the dwell points
[Bdg, Bca] = dwell_time_2d_rect_assemble_conv_mats(...
    tif_params, ...
    Xdg, ...
    Ydg, ...
    Xp, ...
    Yp, ...
    Xtif, ...
    Ytif, ...
    Ztif, ...
    ca_range, ...
    tif_mode ...
);

% 2.3 UDO with t_min and t_max
% initial extension
[~, ~, Zdg, ~, ~] = surface_extension_rectangular(...
    X, ...
    Y, ...
    Z_to_remove, ...
    tif_params, ...
    Ztif, ...
    'smooth', ...
    false ...
);

[~, ~, Zdg, ~, ~] = surface_extension_rectangular(...
    X, ...
    Y, ...
    Z_to_remove, ...
    tif_params, ...
    Ztif,...
    'poly',...
    false,...
    [],[],...
    ini_order_m, ...
    ini_order_n, ...
    ini_type, ...
    Zdg, ...
    ones(size(Zdg)) ...
);

% calculate the initial dwell time
tt = 0;
[t, ~, ~, Z_residual] = dwell_time_2d_rect_udo(...
    Xdg, ...
    Ydg, ...
    Zdg, ...
    tif_params, ...
    Xtif, ...
    Ytif, ...
    Ztif, ...
    Xp, ...
    Yp, ...
    ca_range, ...
    tif_mode, ...
    true, ...
    Bdg, ...
    Bca ...
);
tt = tt + t;

if is_show_result == true
    fsfig('Result of UDO');
    subplot(3, 2, 1);
    show_surface_map(Xtif, Ytif, Ztif, 0, 'parula', 'flat', 0, 2, 1e9, 'nm', 'TIF');
    
    subplot(3, 2, 3);
    show_dwell_time(Xp(:), Yp(:), tt, false, 'hot', 'Dwell Time');
    
    subplot(3, 2, 2);
    show_surface_map(X, Y, Z_to_remove, 0, 'parula', 'flat', 0, 2, 1e9, 'nm', 'Height to remove in CA');
    
    subplot(3, 2, 4);
    show_surface_map(X, Y, Z_residual, 0, 'parula', 'flat', true, 2, 1e9, 'nm', 'Initial estimated residual in CA');
    
    drawnow;
end

% iterative refinement
i = 1;
prev_rms_i = rms_std(Z_residual);

while (true)
    if is_show_result == true
        subplot(3, 2, 5);
        show_dwell_time(Xp(:), Yp(:), tt, false, 'hot', ['Dwell Time, #iter = ' num2str(i)]);
        
        subplot(3, 2, 6);
        show_surface_map(X, Y, Z_residual, 0, 'parula', 'flat', true, 2, 1e9, 'nm', ['Residual, #iter = ' num2str(i)]);
        
        drawnow;
    end
    
    % poly-fif the residual
    Zf = polyfit_2d_rect(X, Y, Z_residual, iter_order_m, iter_order_n, iter_type, false);
    
    % iterative extension again
    [~, ~, Zdg, ca_range, ~] = surface_extension_rectangular(...
        X, ...
        Y, ...
        Zf, ...
        tif_params, ...
        Ztif, ...
        'smooth', ...
        false ...
    );
    [~, ~, Zdg, ~, ~] = surface_extension_rectangular(...
        X, ...
        Y, ...
        Z_residual, ...
        tif_params, ...
        Ztif, ...
        'poly', ...
        false, ...
        [],...
        [], ...
        iter_order_m, ...
        iter_order_n, ...
        iter_type, ...
        Zdg, ...
        ones(size(Zdg)) ...
    );
    
    % call the per-iter udo rise
    [t, ~, ~, Z_residual] = dwell_time_2d_udo_rise_iter(...
        Xdg, ...
        Ydg, ...
        Zdg, ...
        ca_range, ...
        Bdg, ...
        Bca, ...
        learning_rate ...
    );
    
    Z_residual_wo_tilt = remove_polynomials(X, Y, Z_residual, 1);
    curr_rms_i = rms_std(Z_residual);
    
    if curr_rms_i > prev_rms_i
        break;
    elseif rms_std(Z_residual_wo_tilt) < rms_thrd
        tt = tt + t;
        break;
    elseif i > max_iter
        break;
    else
        prev_rms_i = curr_rms_i;
        tt = tt + t;
        i = i + 1;
    end
end

tt = tt - nanmin(tt) + t_min;
tt = tt * ratio;

% 2.4 calculate the residual
z_removal = Bca * tt;
z_residual = Z_to_remove(:) - z_removal;
Z_residual = reshape(z_residual, size(Z));
Z_residual(isnan(Z_to_remove)) = NaN;
Z_residual = remove_polynomials(X, Y, Z_residual, 1);
Z_removal = reshape(z_removal, size(Z));

if is_show_result == true
    subplot(3, 2, 5);
    show_dwell_time(Xp(:), Yp(:), tt, false, 'hot', 'Refined dwell time ');
    
    subplot(3, 2, 6);
    show_surface_map(X, Y, Z_residual, 0, 'parula', 'flat', true, 2, 1e9, 'nm', 'Refined residual');
end

end


%------------------------------- sub rountines----------------------------%
function [t, Z_to_remove_ca, Z_removal_ca, Z_residual_ca] = dwell_time_2d_udo_rise_iter(...
    X, ...
    Y, ...
    Z_to_remove, ...
    ca_range, ...
    Bdg, ...
    Bca, ...
    learning_rate ...
)

% 1. Remove tilts/piston in the clear aperture
X_ca = X(ca_range.vs:ca_range.ve, ca_range.us:ca_range.ue);
Y_ca = Y(ca_range.vs:ca_range.ve, ca_range.us:ca_range.ue);
Z_to_remove_ca = Z_to_remove(ca_range.vs:ca_range.ve, ca_range.us:ca_range.ue);
Z_to_remove_ca = Z_to_remove_ca - nanmin(Z_to_remove_ca(:));
z_to_remove_ca = Z_to_remove_ca(:);

% 2. Remove tilt/piston in the dwell grid based on the clear aperture
Z_to_remove = Z_to_remove - nanmean(Z_to_remove(:));

% 3.Optimize t
t = dwell_time_2d_direct_optimize_t(z_to_remove_ca, Z_to_remove(:), Bca, Bdg);

% 4. Results
t = t * learning_rate;
z_removal_ca = Bca * t;
z_residual_ca = z_to_remove_ca - z_removal_ca;
Z_removal_ca = reshape(z_removal_ca, size(Z_to_remove_ca));
Z_residual_ca = reshape(z_residual_ca, size(Z_to_remove_ca));
Z_residual_ca = remove_polynomials(X_ca, Y_ca, Z_residual_ca, 1);
Z_residual_ca = Z_residual_ca - nanmin(Z_residual_ca(:));

end

function t = dwell_time_2d_direct_optimize_t(...
    z_to_remove_ca, ...
    z_to_remove_dg, ...
    B_ca, ...
    B_dg ...
)
z_dg_2_dp = B_dg'*z_to_remove_dg;    % transform z_dg to the dwell potions' space
z_dg_2_dp = z_dg_2_dp - nanmin(z_dg_2_dp);    % non-negative adjustment

% initial least squares' guess of gamma
gamma0 = (B_dg * (B_dg' * z_to_remove_dg)) \ z_to_remove_dg;

% optimize gamma via patternsearch
gamma_opt = patternsearch(...
    @(gamma)obj_func(gamma, B_ca, z_to_remove_ca, z_dg_2_dp),...
    gamma0...
);

t = gamma_opt * z_dg_2_dp;

end

function fGamma = obj_func(...
    gamma, ...
    B_ca, ...
    z_to_remove_ca, ...
    z_to_remove_dg...
)
% dwell time based on the current gamma
t = gamma * z_to_remove_dg;

% rms of the residual in the clear aperture
fGamma = rms_std(z_to_remove_ca - B_ca*t);

end